<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è€ƒç ”è‹±è¯­è¯åº“æŠ½å–å™¨ (AIé˜…è¯»ç‰ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
            background-color: #f8fafc; /* Tailwind gray-50 */
        }
        .category-item.selected {
            background-color: #dbeafe; /* Tailwind blue-200 */
            border-color: #3b82f6; /* Tailwind blue-500 */
            font-weight: 600;
        }
        /* AIé«˜äº®è¯æ±‡çš„æ ·å¼ */
        .highlighted-word {
            text-decoration: underline;
            text-decoration-color: #fdba74; /* orange-300 */
            text-decoration-thickness: 2px;
            color: #1d4ed8; /* blue-800 */
            font-weight: 600;
            cursor: pointer;
        }
        .highlighted-word:hover {
            background-color: #fef3c7; /* yellow-100 */
            color: #be123c; /* rose-700 */
        }
        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f5f9; /* slate-100 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #94a3b8; /* slate-400 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* slate-500 */
        }
        /* åŠ è½½åŠ¨ç”» */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        
        <!-- æ ‡é¢˜ -->
        <header class="mb-6 pb-4 border-b border-slate-300">
            <h1 class="text-3xl font-bold text-slate-800">è€ƒç ”è‹±è¯­è¯åº“æŠ½å–å™¨ (AI é˜…è¯»ç‰ˆ)</h1>
            <p class="text-slate-600 mt-1">è¯·åœ¨ä¸‹æ–¹ç²˜è´´æ‚¨çš„è¯åº“ï¼Œç„¶åæŒ‰æ¡ç›®æŠ½å–è¯æ±‡å¹¶ç”Ÿæˆ AI é˜…è¯»æ–‡ç« ã€‚</p>
        </header>

        <main class="space-y-6">

            <!-- æ§åˆ¶é¢æ¿ -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                
                <!-- å·¦åˆ— -->
                <div class="space-y-6">
                    <!-- 1. è¯åº“è¾“å…¥ -->
                    <section class="bg-white p-5 rounded-xl shadow-sm border border-slate-200">
                        <h2 class="text-lg font-semibold text-slate-700 mb-3">1. ç²˜è´´è¯åº“</h2>
                        <textarea id="vocab-input" rows="4" class="w-full p-3 border border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="è¯·åœ¨æ­¤å¤„ç²˜è´´æ‚¨çš„è¯åº“..."></textarea>
                        <button id="load-vocab-btn" class="mt-3 w-full bg-blue-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-150 shadow-sm">
                            è½½å…¥è¯åº“
                        </button>
                    </section>
                    
                    <!-- 2. è¯åº“æ€»è§ˆ -->
                    <section class="bg-white p-5 rounded-xl shadow-sm border border-slate-200">
                        <h2 class="text-lg font-semibold text-slate-700 mb-3">2. è¯åº“æ€»è§ˆ</h2>
                        <div class="space-y-2">
                            <div class="flex justify-between items-center p-3 bg-slate-100 rounded-lg">
                                <span class="font-medium text-slate-700">æ€»å‰©ä½™å•è¯:</span>
                                <span id="total-words-count" class="text-xl font-bold text-blue-600">0</span>
                            </div>
                            <div class="flex justify-between items-center p-3 bg-slate-100 rounded-lg">
                                <span class="font-medium text-slate-700">æ€»å‰©ä½™é‡Šä¹‰:</span>
                                <span id="total-meanings-count" class="text-xl font-bold text-blue-600">0</span>
                            </div>
                        </div>
                    </section>

                    <!-- 2.5 è¯åº“å®æ—¶çŠ¶æ€ -->
                    <section class="bg-white p-5 rounded-xl shadow-sm border border-slate-200">
                        <h2 class="text-lg font-semibold text-slate-700 mb-3">2.5 è¯åº“å®æ—¶çŠ¶æ€</h2>
                        <div id="db-status-monitor" class="w-full h-48 overflow-y-auto p-2 border border-slate-200 rounded-lg text-sm bg-slate-50 space-y-1">
                            è¯·å…ˆè½½å…¥è¯åº“...
                        </div>
                    </section>
                </div>
                
                <!-- å³åˆ— -->
                <div class="space-y-6">
                    <!-- 1.5 AI è®¾ç½® -->
                    <section class="bg-white p-5 rounded-xl shadow-sm border border-slate-200">
                        <h2 class="text-lg font-semibold text-slate-700 mb-3">1.5 AI è®¾ç½® (æœ¬åœ°ä½¿ç”¨)</h2>
                        <p class="text-sm text-slate-500 mb-2">æ”¯æŒ Google å®˜æ–¹å¯†é’¥æˆ–ä»£ç†å¯†é’¥ (sk-...)ã€‚</p>
                        
                        <label for="api-key-input" class="text-sm font-medium text-slate-600">API å¯†é’¥ (Key)</label>
                        <input type="password" id="api-key-input" class="w-full p-2 border border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-500 mt-1" placeholder="ç²˜è´´æ‚¨çš„ API Key...">
                        
                        <label for="api-endpoint-input" class="text-sm font-medium text-slate-600 mt-3 block">API åŸºç¡€åœ°å€ (Base URL)</label>
                        <input type="text" id="api-endpoint-input" class="w-full p-2 border border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-500 mt-1" placeholder="ä¾‹å¦‚ https://www.chataiapi.com">
                        
                        <label for="model-name-input" class="text-sm font-medium text-slate-600 mt-3 block">AI æ¨¡å‹åç§° (Model Name)</label>
                        <input type="text" id="model-name-input" class="w-full p-2 border border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-500 mt-1" value="gemini-2.5-flash">
                        
                        <button id="save-api-settings-btn" class="mt-3 w-full bg-green-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-green-700 transition duration-150 shadow-sm">
                            ä¿å­˜ AI è®¾ç½®
                        </button>
                        <p id="api-key-status" class="text-sm text-green-700 mt-2"></p>
                    </section>

                    <!-- 3. æ¡ç›®é€‰æ‹© -->
                    <section class="bg-white p-5 rounded-xl shadow-sm border border-slate-200">
                        <h2 class="text-lg font-semibold text-slate-700 mb-3">3. é€‰æ‹©æ¡ç›®</h2>
                        <div id="category-list" class="space-y-2 max-h-60 overflow-y-auto pr-2">
                            <p class="text-slate-500 text-sm">è¯·å…ˆè½½å…¥è¯åº“...</p>
                            <!-- æ¡ç›®å°†åŠ¨æ€æ’å…¥æ­¤å¤„ -->
                        </div>
                    </section>

                    <!-- 4. æ‰§è¡Œæ“ä½œ -->
                    <section class="bg-white p-5 rounded-xl shadow-sm border border-slate-200 sticky top-8">
                        <h2 class="text-lg font-semibold text-slate-700 mb-3">4. æ‰§è¡Œæ“ä½œ</h2>
                        <button id="extract-words-btn" class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 transition duration-150 shadow-sm disabled:bg-slate-300 disabled:cursor-not-allowed" disabled>
                            1. åˆ·æ–°æŠ½å– (120 é‡Šä¹‰)
                        </button>
                        
                        <button id="gen-reading-btn" class="mt-3 w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition duration-150 shadow-sm disabled:bg-slate-300 disabled:cursor-not-allowed" disabled>
                            <span class="inline-flex items-center justify-center">
                                <span>2. âœ¨ AI ç”Ÿæˆè€ƒç ”é˜…è¯»</span>
                                <span id="ai-loader" class="loader ml-2 hidden"></span>
                            </span>
                        </button>
                        
                        <div id="action-buttons-container" class="mt-3 space-y-3">
                             <button id="confirm-extract-btn" class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 transition duration-150 shadow-sm disabled:bg-slate-300 disabled:cursor-not-allowed hidden">
                                3. âœ… ç¡®è®¤æŠ½å– (æ°¸ä¹…ç§»é™¤)
                            </button>
                             <button id="export-article-btn" class="w-full bg-sky-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-sky-700 transition duration-150 shadow-sm disabled:bg-slate-300 disabled:cursor-not-allowed hidden">
                                4. ğŸ“¥ å¯¼å‡ºæ–‡ç«  (HTML)
                            </button>
                        </div>
                    </section>
                </div>
            </div>

            <!-- ç»“æœæ˜¾ç¤º -->
            <section class="space-y-6">

                <!-- æŠ½å–ç»“æœ -->
                <div class="bg-white p-5 rounded-xl shadow-sm border border-slate-200">
                    <h2 class="text-lg font-semibold text-slate-700 mb-3">æŠ½å–ç»“æœ (120 é‡Šä¹‰)</h2>
                    <div id="extracted-words-list" class="pr-2 grid grid-cols-1 md:grid-cols-3 gap-x-4 gap-y-1 text-sm">
                        <p class="text-slate-500 text-sm col-span-3">è¯·å…ˆé€‰æ‹©æ¡ç›®ï¼Œç„¶åç‚¹å‡» "åˆ·æ–°æŠ½å–"ã€‚</p>
                        <!-- æŠ½å–ç»“æœå°†åŠ¨æ€æ’å…¥æ­¤å¤„ -->
                    </div>
                    <button id="copy-words-btn" class="mt-3 bg-slate-200 text-slate-700 font-medium py-2 px-4 rounded-lg hover:bg-slate-300 transition duration-150 hidden">
                        å¤åˆ¶åˆ°å‰ªè´´æ¿
                    </button>
                    <span id="copy-success-msg" class="text-green-600 ml-2 hidden">å¤åˆ¶æˆåŠŸ!</span>
                </div>

            </section>
        </main>

        <!-- AI è¾“å‡ºå¤§æ¿å— -->
        <section id="ai-output-section" class="mt-6 bg-white p-6 rounded-xl shadow-sm border border-slate-200 hidden">
            
            <!-- AI æ–‡ç«  -->
            <div id="gemini-reading-container">
                <h2 class="text-xl font-semibold text-slate-800 mb-4 pb-3 border-b border-slate-200">
                    AI ç”Ÿæˆçš„é˜…è¯»æ–‡ç«  (<span id="ai-used-count" class="text-blue-600 font-bold">0</span> ä¸ªé‡Šä¹‰å·²ä½¿ç”¨)
                </h2>
                <div id="gemini-reading-output" class="prose prose-lg max-w-none text-gray-800 leading-relaxed space-y-4">
                    <!-- AI æ–‡ç« å†…å®¹ -->
                </div>
            </div>

            <!-- AI æ–‡ç« è§£æ -->
            <div id="gemini-analysis-container" class="mt-6 hidden">
                <h3 class="text-lg font-semibold text-indigo-700 mb-3 pt-3 border-t border-slate-200">
                    æ·±åº¦æ–‡ç« è§£æ
                </h3>
                <div id="gemini-analysis-output" class="prose max-w-none text-gray-700 leading-relaxed bg-indigo-50 p-4 rounded-lg">
                    <!-- AI è§£æå†…å®¹ -->
                </div>
            </div>

            <!-- AI å…¨æ–‡ç¿»è¯‘ -->
            <div id="gemini-translation-container" class="mt-6 hidden">
                <h3 class="text-lg font-semibold text-gray-700 mb-3 pt-3 border-t border-slate-200">
                    å…¨æ–‡ç¿»è¯‘
                </h3>
                <div id="gemini-translation-output" class="prose max-w-none text-gray-600 leading-relaxed bg-gray-50 p-4 rounded-lg">
                    <!-- AI ç¿»è¯‘å†…å®¹ -->
                </div>
            </div>

            <!-- æœªä½¿ç”¨è¯æ±‡ -->
            <div id="gemini-unused-container" class="mt-6 hidden">
                <h3 class="text-lg font-semibold text-gray-700 mb-3 pt-3 border-t border-slate-200">
                    æœªåœ¨æ–‡ç« ä¸­ä½¿ç”¨çš„è¯æ±‡ (å°†ä¿ç•™åœ¨è¯åº“):
                </h3>
                <div id="gemini-unused-output" class="text-sm text-slate-600 space-y-1 max-h-48 overflow-y-auto pr-2">
                    <!-- æœªä½¿ç”¨è¯æ±‡åˆ—è¡¨ -->
                </div>
            </div>

        </section>

    </div>

    <!-- éšè—çš„æ–‡æœ¬åŸŸï¼Œç”¨äºå¤åˆ¶ -->
    <textarea id="copy-textarea" class="absolute -left-full"></textarea>

    <!-- åº•éƒ¨æ¶ˆæ¯æç¤º -->
    <div id="toast" class="fixed bottom-5 right-5 bg-green-600 text-white py-2 px-5 rounded-lg shadow-xl transition-opacity duration-300 opacity-0 hidden">
        ä¿å­˜æˆåŠŸï¼
    </div>

    <script type="module">
        // --- å…¨å±€å˜é‡ä¸å¸¸é‡ ---
        const DB_KEY = 'vocabExtractorDb'; // å­˜å‚¨è¯åº“è¿›åº¦
        const TEXT_KEY = 'vocabExtractorText'; // å­˜å‚¨è¯åº“åŸæ–‡
        const API_KEY = 'vocabExtractorApiKey'; // å­˜å‚¨ç”¨æˆ· API Key
        const API_ENDPOINT = 'vocabExtractorApiEndpoint'; // å­˜å‚¨ç”¨æˆ· API åŸºç¡€åœ°å€
        const MODEL_NAME = 'vocabExtractorModelName'; // å­˜å‚¨ç”¨æˆ· AI æ¨¡å‹åç§°
        
        const GOOGLE_API_BASE_URL = "https://generativelanguage.googleapis.com";
        const GOOGLE_API_PATH_PREFIX = "/v1beta/models/";
        
        let originalDatabase = {}; // { category: [ { word, parts: [ { part, meanings: [] } ] } ] }
        let currentDatabase = {}; // æ·±æ‹·è´ originalDatabaseï¼Œç”¨äºæ“ä½œ
        let currentExtract = []; // å½“å‰æŠ½å–çš„120ä¸ªé‡Šä¹‰å•å…ƒ { word, part, meaning, category, ...indices }
        let currentRealUsedExtractItems = []; // AI å®é™…ä½¿ç”¨çš„ã€ä¸”åœ¨ currentExtract ä¸­åŒ¹é…åˆ°çš„é‡Šä¹‰å•å…ƒ
        let currentAiUsedCount = 0; // currentRealUsedExtractItems.length
        
        let selectedCategory = null; // å½“å‰é€‰ä¸­çš„æ¡ç›®
        let userApiKey = ''; // ç”¨æˆ·å­˜å‚¨çš„ API Key
        let userApiEndpoint = ''; // ç”¨æˆ·å­˜å‚¨çš„ API åŸºç¡€åœ°å€
        let userModelName = 'gemini-2.5-flash'; // é»˜è®¤æ¨¡å‹åç§°

        // --- DOM å…ƒç´ å¼•ç”¨ ---
        const vocabInput = document.getElementById('vocab-input');
        const loadVocabBtn = document.getElementById('load-vocab-btn');
        // const resetVocabBtn = document.getElementById('reset-vocab-btn'); // å·²ç§»é™¤
        const totalWordsCountEl = document.getElementById('total-words-count');
        const totalMeaningsCountEl = document.getElementById('total-meanings-count');
        const categoryListEl = document.getElementById('category-list');
        const extractWordsBtn = document.getElementById('extract-words-btn');
        const confirmExtractBtn = document.getElementById('confirm-extract-btn');
        const genReadingBtn = document.getElementById('gen-reading-btn');
        const aiLoader = document.getElementById('ai-loader');
        const extractedWordsListEl = document.getElementById('extracted-words-list');
        const copyWordsBtn = document.getElementById('copy-words-btn');
        const copySuccessMsg = document.getElementById('copy-success-msg');
        const copyTextarea = document.getElementById('copy-textarea');
        const exportArticleBtn = document.getElementById('export-article-btn');
        
        // [New] è¯åº“çŠ¶æ€ç›‘è§†å™¨
        const dbStatusMonitor = document.getElementById('db-status-monitor');
        
        // AI è¾“å‡ºåŒºåŸŸ
        const aiOutputSection = document.getElementById('ai-output-section');
        const aiUsedCountEl = document.getElementById('ai-used-count');
        
        const geminiReadingContainer = document.getElementById('gemini-reading-container');
        const geminiReadingOutput = document.getElementById('gemini-reading-output');
        
        const geminiUnusedContainer = document.getElementById('gemini-unused-container');
        const geminiUnusedOutput = document.getElementById('gemini-unused-output');
        
        const geminiAnalysisContainer = document.getElementById('gemini-analysis-container');
        const geminiAnalysisOutput = document.getElementById('gemini-analysis-output');

        const geminiTranslationContainer = document.getElementById('gemini-translation-container');
        const geminiTranslationOutput = document.getElementById('gemini-translation-output');
        
        // AI è®¾ç½®åŒºåŸŸ
        const apiKeyInput = document.getElementById('api-key-input');
        const apiEndpointInput = document.getElementById('api-endpoint-input');
        const modelNameInput = document.getElementById('model-name-input');
        const saveApiSettingsBtn = document.getElementById('save-api-settings-btn');
        const apiKeyStatus = document.getElementById('api-key-status');
        const toast = document.getElementById('toast');


        // --- 1. è¯åº“è§£æä¸ç®¡ç† ---

        /**
         * è¯æ€§è¯å…¸ (V4 - ä¿®å¤ 'centigrade n./adj.' BUG)
         */
        // [ä¿®å¤] æ ¹æ®ç”¨æˆ·çš„æƒå¨åˆ—è¡¨ï¼Œå½»åº•é‡æ„
        const POS_LIST = [
            'adj./adv.', 'prep./adv.', 'n./adj.', 'n./v.', 'v./n.', // ä¼˜å…ˆåŒ¹é…æœ€é•¿çš„
            'adj.', 'adv.', 'n.', 'v.', 'num.', 'prep.', 'vt.', 'vi.',
        ];

        // [ä¿®å¤] åˆ›å»ºä¸¤ä¸ª Set ç”¨äºå¿«é€ŸæŸ¥æ‰¾
        // POS_DICT_WITH_DOT: { "v./n.", "adj.", "n." }
        const POS_DICT_WITH_DOT = new Set(POS_LIST);
        // POS_DICT_WITHOUT_DOT: { "v./n", "adj", "n" }
        const POS_DICT_WITHOUT_DOT = new Set(POS_LIST.map(p => p.slice(0, -1)));
        

        /**
         * è§£æè¾“å…¥çš„è¯åº“æ–‡æœ¬ (V11 - ä¿®å¤ 'centigrade n./adj.' BUG)
         */
        function parseVocabText(text) {
            const lines = text.split('\n').filter(line => line.trim() !== '');
            const db = {};
            let currentCategory = 'æœªåˆ†ç±»';

            // [V11 ä¿®å¤] 
            // 1. æ„å»ºæŒ‰é•¿åº¦æ’åºçš„ *åŒ¹é…* æ­£åˆ™
            // (e.g., n\.\s*\/\s*adj\.|...|adj\.)
            const posPattern_sorted = POS_LIST
                .map(p => p.replace(/\./g, '\\.').replace(/\//g, '\\s*\\/\\s*')) // V7 ä¿®å¤
                .sort((a, b) => b.length - a.length) // ä¼˜å…ˆåŒ¹é…é•¿çš„
                .join('|');
            
            // 2. è¿™æ˜¯ç”¨äº *åŒ¹é…* å­—ç¬¦ä¸²å¼€å¤´çš„æ­£åˆ™
            const matchRegex = new RegExp(`^(${posPattern_sorted})\\s*(.*)`);
            // 3. è¿™æ˜¯ç”¨äº *æŸ¥æ‰¾* å‰©ä½™å­—ç¬¦ä¸²ä¸­ *ä¸‹ä¸€ä¸ª* è¯æ€§çš„æ­£åˆ™
            const findNextRegex = new RegExp(`(${posPattern_sorted})`, 'g');


            lines.forEach(line => {
                line = line.trim();
                if (line.startsWith('###')) {
                    // åŒ¹é…æ¡ç›®
                    currentCategory = line.replace(/###\s*/, '').trim();
                    if (!db[currentCategory]) {
                        db[currentCategory] = [];
                    }
                } else if (line) {
                    // è§£æå•è¯è¡Œ
                    const parts = line.split(' ');
                    if (parts.length < 2) return; // æ ¼å¼ä¸ç¬¦

                    const word = parts[0];
                    const definitions = line.substring(word.length).trim(); // "n.å—;è‚¿å— v.å½¢æˆå—"
                    
                    const wordEntry = {
                        word: word,
                        parts: [] // { part: 'v.', meanings: ['å½¢æˆå—'] }
                    };

                    // [V11 ä¿®å¤] ä½¿ç”¨è¿­ä»£æ¶ˆè€—é€»è¾‘ï¼Œæ›¿æ¢ V7/V10 çš„ split() é€»è¾‘
                    let remainingDefinitions = definitions.trim();

                    while (remainingDefinitions.length > 0) {
                        const match = remainingDefinitions.match(matchRegex);
                        
                        if (!match) {
                            // å‰©ä½™å­—ç¬¦ä¸²ä¸ä»¥è¯æ€§å¼€å¤´ï¼Œé€€å‡º
                            break; 
                        }
                        
                        const currentPart = match[1]; // e.g., "n./adj." (V11 ä¿®å¤) or "n."
                        let meaningsStr = match[2]; // e.g., "æ‘„æ°æ¸©åº¦è®¡ï¼ˆçš„ï¼‰" or "å—;è‚¿å— v.å½¢æˆå—"
                        
                        // æŸ¥æ‰¾ meaningsStr ä¸­æ˜¯å¦ *è¿˜åŒ…å«* å…¶å®ƒè¯æ€§
                        findNextRegex.lastIndex = 0; // é‡ç½®æ­£åˆ™
                        const nextMatch = findNextRegex.exec(meaningsStr);
                        
                        if (nextMatch) {
                            // æ‰¾åˆ°äº†ä¸‹ä¸€ä¸ªè¯æ€§ (e.g., "v." in "å—;è‚¿å— v.å½¢æˆå—")
                            // 1. æ›´æ–° remainingDefinitions ä¸ºä¸‹ä¸€ä¸ªè¯æ€§åŠå…¶ä¹‹å
                            remainingDefinitions = meaningsStr.substring(nextMatch.index).trim();
                            // 2. æˆªå–å½“å‰è¯æ€§çš„é‡Šä¹‰
                            meaningsStr = meaningsStr.substring(0, nextMatch.index).trim();
                        } else {
                            // æœªæ‰¾åˆ°ä¸‹ä¸€ä¸ªè¯æ€§ï¼Œè¿™æ˜¯æœ€åä¸€ä¸ª
                            remainingDefinitions = ""; // é€€å‡º while å¾ªç¯
                            meaningsStr = meaningsStr.trim();
                        }

                        // [V10 é€»è¾‘ä¿ç•™] æ£€æŸ¥ meaningsStr æ˜¯å¦åªæ˜¯ä¸€ä¸ªå­¤ç«‹çš„è¯æ€§
                        const meaningsStrTrimmed = meaningsStr.trim();
                        const meaningsStrCleaned = meaningsStrTrimmed.endsWith('.') 
                                            ? meaningsStrTrimmed.slice(0, -1) 
                                            : meaningsStrTrimmed;
                        const isOnlyPos = POS_DICT_WITH_DOT.has(meaningsStrTrimmed) ||
                                          POS_DICT_WITHOUT_DOT.has(meaningsStrCleaned);
                        
                        if (meaningsStr && !isOnlyPos) { 
                            // [V10 é€»è¾‘ä¿ç•™]
                            const meanings = meaningsStr.split(';').map(m => m.trim()).filter(m => m);
                            
                            const finalMeanings = meanings.filter(m => {
                                if (m === '/' || m.trim() === '') return false; 
                                const mTrimmed = m.trim();
                                const mCleaned = mTrimmed.endsWith('.') ? mTrimmed.slice(0, -1) : mTrimmed;
                                const isMeaningPos = POS_DICT_WITH_DOT.has(mTrimmed) ||
                                                     POS_DICT_WITHOUT_DOT.has(mCleaned);
                                return !isMeaningPos; 
                            });
                            
                            if (finalMeanings.length > 0) {
                                wordEntry.parts.push({
                                    part: currentPart,
                                    meanings: finalMeanings
                                });
                            }
                        }
                        // å¦‚æœ meaningsStr ä¸ºç©º (e.g., "n. v") æˆ– isOnlyPos (e.g., "stick n. v")
                        // åˆ™ä¸æ·»åŠ è¿™ä¸ªè¯æ€§éƒ¨åˆ†
                    }
                    
                    if (wordEntry.parts.length > 0) {
                        if (!db[currentCategory]) {
                            db[currentCategory] = [];
                        }
                        db[currentCategory].push(wordEntry);
                    }
                }
            });
            return db;
        }

        /**
         * è®¡ç®—æ•°æ®åº“ä¸­çš„æ€»å•è¯æ•°å’Œæ€»é‡Šä¹‰æ•°
         * @param {object} db - è¯åº“
         * @returns {object} { totalWords, totalMeanings }
         */
        function getDatabaseStats(db) {
            let totalWords = 0;
            let totalMeanings = 0;
            for (const category in db) {
                totalWords += db[category].length;
                db[category].forEach(wordEntry => {
                    wordEntry.parts.forEach(part => {
                        totalMeanings += part.meanings.length;
                    });
                });
            }
            return { totalWords, totalMeanings };
        }

        /**
         * è®¡ç®—æŒ‡å®šåˆ†ç±»çš„ç»Ÿè®¡ä¿¡æ¯
         */
        function getCategoryStats(db, category) {
            let words = 0;
            let meanings = 0;
            if (db[category]) {
                words = db[category].length;
                db[category].forEach(wordEntry => {
                    wordEntry.parts.forEach(part => {
                        meanings += part.meanings.length;
                    });
                });
            }
            return { words, meanings };
        }

        /**
         * æ·±æ‹·è´ (ç”¨äºåˆ›å»ºå¯æ“ä½œçš„ currentDatabase)
         */
        function deepClone(obj) {
            return JSON.parse(JSON.stringify(obj));
        }

        // --- 2. ç•Œé¢æ›´æ–°ä¸æ¸²æŸ“ ---

        /**
         * [New] æ›´æ–°è¯åº“å®æ—¶çŠ¶æ€ç›‘è§†å™¨ (V12 - UI ä¼˜åŒ–)
         */
        function updateDbStatusMonitor() {
            dbStatusMonitor.innerHTML = ''; // æ¸…ç©º
            
            const categories = Object.keys(currentDatabase);

            if (categories.length === 0) {
                dbStatusMonitor.innerHTML = '<p class="text-slate-500 p-2">è¯åº“ä¸ºç©ºã€‚</p>';
                return;
            }

            categories.forEach((category, index) => {
                const words = currentDatabase[category];
                
                // 1. åˆ›å»º <details> å…ƒç´ 
                const detailsEl = document.createElement('details');
                detailsEl.className = "group"; // ç”¨äºæ§åˆ¶ marker
                
                // 2. åˆ›å»º <summary> å…ƒç´  (æ¡ç›®)
                const summaryEl = document.createElement('summary');
                // [V12] ä½¿ç”¨ flex å¸ƒå±€è‡ªå®šä¹‰ç®­å¤´å’Œæ–‡æœ¬
                summaryEl.className = "flex items-center list-none p-1 rounded-md cursor-pointer hover:bg-slate-200 sticky top-0 bg-slate-50"; // sticky ä¿è¯æ ‡é¢˜å¯è§
                
                // è‡ªå®šä¹‰ç®­å¤´
                const arrow = document.createElement('span');
                arrow.className = "w-4 h-4 text-slate-500 group-open:rotate-90 transition-transform duration-100 mr-1 flex-shrink-0";
                arrow.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m8.25 4.5 7.5 7.5-7.5 7.5" /></svg>`;
                
                // æ¡ç›®æ–‡æœ¬å’Œç»Ÿè®¡
                const summaryText = document.createElement('span');
                summaryText.textContent = `${category} (${words.length} è¯)`;
                summaryText.className = "font-semibold text-indigo-700"; // æ¡ç›®é¢œè‰²
                
                summaryEl.appendChild(arrow);
                summaryEl.appendChild(summaryText);
                
                detailsEl.appendChild(summaryEl);

                // 3. åˆ›å»ºå•è¯å®¹å™¨
                const wordsContainer = document.createElement('div');
                wordsContainer.className = "pl-5 pr-2 pt-1 pb-2 space-y-2"; // ç¼©è¿›

                words.forEach(wordEntry => {
                    const wordBlock = document.createElement('div');
                    
                    // å•è¯
                    const wordSpan = document.createElement('span');
                    wordSpan.textContent = wordEntry.word;
                    wordSpan.className = "font-medium text-slate-800"; // å•è¯é¢œè‰²
                    wordBlock.appendChild(wordSpan);

                    // è¯æ€§å’Œé‡Šä¹‰
                    const partsContainer = document.createElement('div');
                    partsContainer.className = "pl-3 space-y-1"; // è¯æ€§ç¼©è¿›

                    wordEntry.parts.forEach(partEntry => {
                        const partEl = document.createElement('div');
                        
                        // è¯æ€§
                        const partSpan = document.createElement('span');
                        partSpan.textContent = partEntry.part;
                        partSpan.className = "text-green-700 italic font-medium text-xs mr-2"; // è¯æ€§é¢œè‰²
                        
                        // é‡Šä¹‰
                        const meaningsSpan = document.createElement('span');
                        meaningsSpan.textContent = partEntry.meanings.join('; ');
                        meaningsSpan.className = "text-gray-700"; // é‡Šä¹‰é¢œè‰²

                        partEl.appendChild(partSpan);
                        partEl.appendChild(meaningsSpan);
                        partsContainer.appendChild(partEl);
                    });
                    
                    wordBlock.appendChild(partsContainer);
                    wordsContainer.appendChild(wordBlock);
                });
                
                detailsEl.appendChild(wordsContainer);
                dbStatusMonitor.appendChild(detailsEl);

                // é»˜è®¤å±•å¼€ç¬¬ä¸€ä¸ªæ¡ç›®
                if (index === 0) {
                    detailsEl.open = true;
                }
            });
        }

        /**
         * æ›´æ–°"è¯åº“æ€»è§ˆ"çš„æ˜¾ç¤º
         */
        function updateTotalStatsDisplay() {
            const { totalWords, totalMeanings } = getDatabaseStats(currentDatabase);
            totalWordsCountEl.textContent = totalWords;
            totalMeaningsCountEl.textContent = totalMeanings;
        }

        /**
         * æ›´æ–°"æ¡ç›®é€‰æ‹©"åŒºåŸŸçš„æ˜¾ç¤º
         */
        function initializeCategorySelection() {
            categoryListEl.innerHTML = ''; // æ¸…ç©º
            const categories = Object.keys(currentDatabase);
            
            if (categories.length === 0) {
                categoryListEl.innerHTML = '<p class="text-slate-500 text-sm">è¯·å…ˆè½½å…¥è¯åº“...</p>';
                return;
            }

            categories.forEach(category => {
                const { words, meanings } = getCategoryStats(currentDatabase, category);
                const item = document.createElement('div');
                item.className = 'category-item p-3 border border-slate-200 rounded-lg cursor-pointer hover:bg-slate-100 hover:shadow-md transition-all duration-150';
                item.dataset.category = category;
                item.innerHTML = `
                    <div class="flex justify-between items-center">
                        <span class="font-medium text-slate-800 text-sm">${category}</span>
                    </div>
                    <div class="flex justify-between items-center mt-2 text-xs">
                        <span class="text-slate-500">å•è¯: <span class="font-semibold text-slate-700">${words}</span></span>
                        <span class="text-slate-500">é‡Šä¹‰: <span class="font-semibold text-slate-700">${meanings}</span></span>
                    </div>
                `;
                item.addEventListener('click', () => handleCategorySelect(category, item));
                categoryListEl.appendChild(item);
            });
            
            // è‡ªåŠ¨é€‰æ‹©ä¸Šä¸€æ¬¡é€‰æ‹©çš„æ¡ç›®
            if (selectedCategory && currentDatabase[selectedCategory]) {
                const el = categoryListEl.querySelector(`[data-category="${CSS.escape(selectedCategory)}"]`);
                if (el) {
                    el.classList.add('selected');
                    extractWordsBtn.disabled = false;
                }
            }
        }

        /**
         * æ›´æ–°å•ä¸ªæ¡ç›®çš„ç»Ÿè®¡æ˜¾ç¤º
         */
        function updateCategoryStatsDisplay(category) {
            const item = categoryListEl.querySelector(`[data-category="${CSS.escape(category)}"]`);
            if (item) {
                const { words, meanings } = getCategoryStats(currentDatabase, category);
                item.querySelector('.text-xs').innerHTML = `
                    <span class="text-slate-500">å•è¯: <span class="font-semibold text-slate-700">${words}</span></span>
                    <span class="text-slate-500">é‡Šä¹‰: <span class="font-semibold text-slate-700">${meanings}</span></span>
                `;
                // å¦‚æœè¯¥æ¡ç›®ç©ºäº†ï¼Œæ˜¾ç¤ºä¸åŒæ ·å¼
                if (words === 0 && meanings === 0) {
                    item.classList.add('opacity-50', 'line-through');
                    item.classList.remove('selected');
                    // ç¦ç”¨æŠ½å–æŒ‰é’®
                    if (selectedCategory === category) {
                        extractWordsBtn.disabled = true;
                        selectedCategory = null;
                    }
                }
            }
            // æ¯æ¬¡æ›´æ–°æ¡ç›®åï¼Œéƒ½åŒæ­¥æ›´æ–°æ€»è§ˆ
            updateTotalStatsDisplay();
        }

        /**
         * æ¸²æŸ“æŠ½å–çš„120ä¸ªé‡Šä¹‰
         */
        function renderExtractedWords(words) {
            extractedWordsListEl.innerHTML = ''; // æ¸…ç©º
            if (words.length === 0) {
                extractedWordsListEl.innerHTML = '<p class="text-slate-500 text-sm col-span-3">è¯¥æ¡ç›®å·²æŠ½ç©ºï¼</p>';
                copyWordsBtn.style.display = 'none';
                genReadingBtn.disabled = true;
                return;
            }
            
            // [ä¿®å¤] ç§»é™¤ max-h-96 å’Œ overflow-y-auto, è®¾ä¸º 3 åˆ—
            extractedWordsListEl.className = 'pr-2 grid grid-cols-1 md:grid-cols-3 gap-x-4 gap-y-1 text-sm';
            
            let copyText = '';
            words.forEach(item => {
                const el = document.createElement('div');
                const text = `${item.word} ${item.part} ${item.meaning}`;
                el.textContent = text;
                el.className = 'py-1 px-2 hover:bg-slate-100 rounded';
                extractedWordsListEl.appendChild(el);
                copyText += text + '\n';
            });
            
            copyTextarea.value = copyText;
            copyWordsBtn.style.display = 'inline-block';
            copySuccessMsg.style.display = 'none';
            
            // å¯ç”¨ AI æŒ‰é’®
            genReadingBtn.disabled = false;
        }

        // --- 3. äº‹ä»¶å¤„ç†å™¨ ---

        /**
         * ä¿å­˜ AI è®¾ç½®
         */
        saveApiSettingsBtn.addEventListener('click', () => {
            const key = apiKeyInput.value.trim();
            const endpoint = apiEndpointInput.value.trim();
            const model = modelNameInput.value.trim();
            
            if (key) {
                localStorage.setItem(API_KEY, key);
                userApiKey = key;
            }
            
            if (model) {
                localStorage.setItem(MODEL_NAME, model);
                userModelName = model;
            } else {
                localStorage.removeItem(MODEL_NAME);
                userModelName = 'gemini-2.5-flash'; // é»˜è®¤æ¨¡å‹
                modelNameInput.value = userModelName;
            }
            
            if (endpoint) {
                const cleanedEndpoint = endpoint.replace(/\/$/, '');
                localStorage.setItem(API_ENDPOINT, cleanedEndpoint);
                userApiEndpoint = cleanedEndpoint;
                apiEndpointInput.value = cleanedEndpoint;
            } else {
                localStorage.removeItem(API_ENDPOINT);
                userApiEndpoint = '';
            }
            
            apiKeyStatus.textContent = "AI è®¾ç½®å·²ä¿å­˜åˆ°æœ¬åœ°æµè§ˆå™¨ã€‚";
            showToast("è®¾ç½®å·²ä¿å­˜");
            
            setTimeout(() => {
                apiKeyStatus.textContent = "";
            }, 3000);
        });

        /**
         * æ˜¾ç¤º Toast æç¤º
         */
        function showToast(message) {
            toast.textContent = message;
            toast.style.display = 'block';
            toast.style.opacity = '1';
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => {
                    toast.style.display = 'none';
                }, 300);
            }, 2000);
        }

        /**
         * è½½å…¥æ—¶æ£€æŸ¥ AI è®¾ç½®
         */
        function loadApiSettings() {
            const savedKey = localStorage.getItem(API_KEY);
            const savedEndpoint = localStorage.getItem(API_ENDPOINT);
            const savedModel = localStorage.getItem(MODEL_NAME);
            
            if (savedKey) {
                userApiKey = savedKey;
                apiKeyInput.value = savedKey;
            }
            if (savedEndpoint) {
                userApiEndpoint = savedEndpoint;
                apiEndpointInput.value = savedEndpoint;
            }
            if (savedModel) {
                userModelName = savedModel;
                modelNameInput.value = savedModel;
            } else {
                modelNameInput.value = userModelName; // æ˜¾ç¤ºé»˜è®¤å€¼
            }
            
            if (savedKey) {
                apiKeyStatus.textContent = "å·²ä»æœ¬åœ°æµè§ˆå™¨è½½å…¥ AI è®¾ç½®ã€‚";
            } else {
                apiKeyStatus.textContent = "è¯·æä¾› API å¯†é’¥ä»¥ä½¿ç”¨ AI åŠŸèƒ½ã€‚";
            }
        }

        /**
         * è½½å…¥è¯åº“æŒ‰é’®
         */
        loadVocabBtn.addEventListener('click', () => {
            const text = vocabInput.value;
            if (text.trim() === '') return;
            
            originalDatabase = parseVocabText(text);
            currentDatabase = deepClone(originalDatabase);
            
            localStorage.setItem(TEXT_KEY, text);
            localStorage.setItem(DB_KEY, JSON.stringify(currentDatabase));

            updateTotalStatsDisplay();
            initializeCategorySelection();
            updateDbStatusMonitor(); // [New] Call
            
            resetUiOutputs();
            showToast("è¯åº“è½½å…¥å¹¶ä¿å­˜æˆåŠŸï¼");
        });

        /**
         * é‡ç½®è¯åº“æŒ‰é’®
         */
        // resetVocabBtn.addEventListener('click', ...); // æ•´ä¸ªå‡½æ•°å·²ç§»é™¤

        /**
         * é€‰æ‹©æ¡ç›®
         */
        function handleCategorySelect(category, element) {
            document.querySelectorAll('.category-item.selected').forEach(el => {
                el.classList.remove('selected');
            });

            element.classList.add('selected');
            selectedCategory = category;

            const { meanings } = getCategoryStats(currentDatabase, category);
            if (meanings > 0) {
                extractWordsBtn.disabled = false;
            } else {
                extractWordsBtn.disabled = true;
            }
            
            resetUiOutputs();
        }

        /**
         * 1. åˆ·æ–°æŠ½å– (120 è¯)
         */
        extractWordsBtn.addEventListener('click', handleExtractWords);
        
        function handleExtractWords() {
            if (!selectedCategory || !currentDatabase[selectedCategory]) return;
            
            const EXTRACT_COUNT = 120;
            const categoryWords = currentDatabase[selectedCategory];
            const availableMeanings = []; 

            categoryWords.forEach((wordEntry, wordIndex) => {
                wordEntry.parts.forEach((part, partIndex) => {
                    part.meanings.forEach((meaning, meaningIndex) => {
                        availableMeanings.push({
                            word: wordEntry.word,
                            part: part.part,
                            meaning: meaning,
                            category: selectedCategory,
                            wordIndex: wordIndex,
                            partIndex: partIndex,
                            meaningIndex: meaningIndex
                        });
                    });
                });
            });

            shuffleArray(availableMeanings);

            currentExtract = availableMeanings.slice(0, EXTRACT_COUNT);

            renderExtractedWords(currentExtract);

            genReadingBtn.disabled = (currentExtract.length === 0);
            confirmExtractBtn.style.display = 'none';
            confirmExtractBtn.disabled = true;
            exportArticleBtn.style.display = 'none';
            
            aiOutputSection.style.display = 'none';
        }

        /**
         * 3. ç¡®è®¤æŠ½å– (æ°¸ä¹…ç§»é™¤)
         */
        confirmExtractBtn.addEventListener('click', () => {
            
            if (currentAiUsedCount === 0 || !selectedCategory) {
                 console.error("ç¡®è®¤æŠ½å–å¤±è´¥ï¼Œæ²¡æœ‰å·²ç”¨è¯æ±‡æˆ–æœªé€‰æ¡ç›®ã€‚");
                 return;
            }

            let removedCount = 0;
            // [ä¿®å¤] å¿…é¡»ä½¿ç”¨ currentRealUsedExtractItems (çœŸå®åŒ¹é…çš„é‡Šä¹‰å•å…ƒ)
            const itemsToRemoveFromDb = currentRealUsedExtractItems; 
            
            // åå‘æ’åºç´¢å¼•ï¼Œä»åå¾€å‰åˆ é™¤ï¼Œé¿å…ç´¢å¼•é”™ä½
            itemsToRemoveFromDb.sort((a, b) => {
                if (a.wordIndex !== b.wordIndex) return b.wordIndex - a.wordIndex;
                if (a.partIndex !== b.partIndex) return b.partIndex - b.partIndex;
                return b.meaningIndex - b.meaningIndex;
            });

            const deletedIndexes = new Set(); // é˜²æ­¢é‡å¤åˆ é™¤
            
            itemsToRemoveFromDb.forEach(item => {
                const uniqueId = `${item.wordIndex}-${item.partIndex}-${item.meaningIndex}`;
                if (deletedIndexes.has(uniqueId)) {
                    return; // å·²ç»åˆ è¿‡äº†
                }

                try {
                    // å¿…é¡»ä» currentDatabase[item.category] ä¸­è·å–æœ€æ–°çš„å¼•ç”¨
                    const wordEntry = currentDatabase[item.category][item.wordIndex];
                    if (wordEntry && wordEntry.word === item.word) {
                        const partEntry = wordEntry.parts[item.partIndex];
                        if (partEntry && partEntry.part === item.part) {
                            const meaning = partEntry.meanings[item.meaningIndex];
                            if (meaning === item.meaning) {
                                // æ‰§è¡Œåˆ é™¤
                                partEntry.meanings.splice(item.meaningIndex, 1);
                                removedCount++;
                                deletedIndexes.add(uniqueId); 

                                // å¦‚æœè¯¥è¯æ€§ä¸‹æ²¡æœ‰é‡Šä¹‰äº†ï¼Œåˆ é™¤è¯¥è¯æ€§
                                if (partEntry.meanings.length === 0) {
                                    wordEntry.parts.splice(item.partIndex, 1);
                                }
                                
                                // å¦‚æœè¯¥å•è¯ä¸‹æ²¡æœ‰è¯æ€§äº†ï¼Œåˆ é™¤è¯¥å•è¯
                                if (wordEntry.parts.length === 0) {
                                    currentDatabase[item.category].splice(item.wordIndex, 1);
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error("Error removing word from DB:", e, item);
                }
            });

            if (removedCount > 0) {
                localStorage.setItem(DB_KEY, JSON.stringify(currentDatabase));
                updateCategoryStatsDisplay(selectedCategory);
                updateDbStatusMonitor(); // [New] Call
            }

            // é‡ç½®UI
            extractWordsBtn.disabled = false;
            genReadingBtn.disabled = true;
            confirmExtractBtn.style.display = 'none';
            confirmExtractBtn.disabled = true;
            // [æ–°åŠŸèƒ½] å¯¼å‡ºæŒ‰é’®ä¹Ÿä¼šè¢«é‡ç½®(éšè—)
            // exportArticleBtn.style.display = 'none'; // ä¿ç•™å¯¼å‡ºæŒ‰é’®ï¼Œä½†ç¦ç”¨
            exportArticleBtn.disabled = true;


            extractedWordsListEl.innerHTML = '<p class="text-slate-500 text-sm col-span-3">å·²ç¡®è®¤ã€‚è¯·é‡æ–° "åˆ·æ–°æŠ½å–"ã€‚</p>';
            copyWordsBtn.style.display = 'none';

            // æ¸…ç©ºå½“å‰çŠ¶æ€
            currentExtract = [];
            currentRealUsedExtractItems = [];
            currentAiUsedCount = 0; // [ä¿®å¤] é‡ç½®è®¡æ•°å™¨
            
            // ä¿ç•™æ–‡ç« ï¼Œä½†éšè—"æœªä½¿ç”¨"åˆ—è¡¨
            geminiUnusedContainer.style.display = 'none';
            
            showToast(`æˆåŠŸç§»é™¤äº† ${removedCount} ä¸ªé‡Šä¹‰`);
        });

        /**
         * å¤åˆ¶æŒ‰é’®
         */
        copyWordsBtn.addEventListener('click', () => {
            copyTextarea.select();
            try {
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(copyTextarea.value).then(() => {
                        copySuccessMsg.style.display = 'inline';
                        setTimeout(() => {
                            copySuccessMsg.style.display = 'none';
                        }, 2000);
                    }, () => {
                        document.execCommand('copy');
                        copySuccessMsg.style.display = 'inline';
                         setTimeout(() => {
                            copySuccessMsg.style.display = 'none';
                        }, 2000);
                    });
                } else {
                    document.execCommand('copy');
                    copySuccessMsg.style.display = 'inline';
                    setTimeout(() => {
                        copySuccessMsg.style.display = 'none';
                    }, 2000);
                }
            } catch (err) {
                console.error('Fallback: Oops, unable to copy', err);
            }
            window.getSelection().removeAllRanges();
        });

        /**
         * é‡ç½®æ‰€æœ‰è¾“å‡ºåŒºåŸŸ (å·¦å³ä¾§)
         */
        function resetUiOutputs() {
            extractedWordsListEl.innerHTML = '<p class="text-slate-500 text-sm col-span-3">è¯·å…ˆé€‰æ‹©æ¡ç›®ï¼Œç„¶åç‚¹å‡» "åˆ·æ–°æŠ½å–"ã€‚</p>';
            copyWordsBtn.style.display = 'none';
            copySuccessMsg.style.display = 'none';
            
            aiOutputSection.style.display = 'none';
            geminiReadingOutput.innerHTML = '';
            geminiUnusedOutput.innerHTML = '';
            geminiAnalysisOutput.innerHTML = '';
            geminiTranslationOutput.innerHTML = '';
            aiUsedCountEl.textContent = '0';

            genReadingBtn.disabled = true;
            confirmExtractBtn.style.display = 'none';
            confirmExtractBtn.disabled = true;
            exportArticleBtn.style.display = 'none';

            currentExtract = [];
            currentRealUsedExtractItems = [];
            currentAiUsedCount = 0;
        }

        /**
         * Fisher-Yates æ´—ç‰Œç®—æ³•
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // --- 4. Gemini AI åŠŸèƒ½ ---

        /**
         * HTML å®ä½“è§£ç  (ä¿®å¤ &quot; é—®é¢˜)
         */
        function decodeHTMLEntities(text) {
            if (typeof text !== 'string') return text;
            
            let decodedText = text;

            // 1. å…ˆè§£ç å¸¸è§çš„è½¬ä¹‰å®ä½“
            try {
                 // [ä¿®å¤] å¿…é¡»å…ˆè§£ç  &quot;
                 decodedText = decodedText.replace(/&quot;/g, '"')
                                     .replace(/&lt;/g, '<')
                                     .replace(/&gt;/g, '>')
                                     .replace(/&amp;/g, '&')
                                     .replace(/\\"/g, '"'); // è§£ç è½¬ä¹‰çš„å¼•å·
            } catch(e) { console.error("Error in regex replace:", e); }

            // 2. [ä¿®å¤] ç§»é™¤AIå¯èƒ½é”™è¯¯æ·»åŠ çš„ \ (ä¾‹å¦‚ \n)
            try {
                // åªæ›¿æ¢ \\n å’Œ \\t, ä¿ç•™ \n
                decodedText = decodedText.replace(/\\\\n/g, '\n').replace(/\\\\t/g, '\t');
                
            } catch(e) { console.error("Error cleaning backslashes:", e); }


            // 3. ä½¿ç”¨ textarea åšæœ€ç»ˆè§£ç  (ç”¨äº &apos; &#39; ç­‰)
            try {
                const textarea = document.createElement('textarea');
                textarea.innerHTML = decodedText;
                return textarea.value;
            } catch (e) {
                console.error("Error decoding with textarea:", e);
                return decodedText; // è¿”å›å·²è§£ç çš„éƒ¨åˆ†
            }
        }

        /**
         * 2. AI ç”Ÿæˆè€ƒç ”é˜…è¯»
         */
        genReadingBtn.addEventListener('click', handleGenReading);

        async function handleGenReading() {
            if (currentExtract.length === 0) {
                showAiError("æ²¡æœ‰å¯ç”¨äºç”Ÿæˆæ–‡ç« çš„è¯æ±‡ã€‚");
                return;
            }
            
            const wordListString = currentExtract.map(item => `- ${item.word} (${item.part} ${item.meaning})`).join('\n');
            const categoryName = selectedCategory || "ç»¼åˆä¸»é¢˜";
            
            const themeOnly = categoryName.replace(/###\s*[\IVXLC]+\.\s*/, '').split('(')[0].trim();
            const themeFinal = themeOnly.replace(/ã€|ä¸/g, 'æˆ–'); 

            let apiKey = userApiKey;
            // æ£€æŸ¥æ˜¯å¦åœ¨ Canvas ç¯å¢ƒä¸­
            if (!apiKey && typeof __app_id !== 'undefined') {
                apiKey = ""; // åœ¨ Canvas ä¸­ï¼Œè®¾ç½®ä¸ºç©ºå­—ç¬¦ä¸²ä»¥ä½¿ç”¨æä¾›çš„å¯†é’¥
            }
            
            if (apiKey === null || apiKey === undefined) {
                showAiError("AI è¯·æ±‚å¤±è´¥ï¼šæœªæä¾› API å¯†é’¥ã€‚è¯·åœ¨å·¦ä¾§ 'AI è®¾ç½®' æ¡†ä¸­è¾“å…¥æ‚¨çš„å¯†é’¥ã€‚");
                apiKeyStatus.textContent = "è¯·æä¾› API å¯†é’¥ä»¥ä½¿ç”¨ AI åŠŸèƒ½ã€‚";
                return;
            }
            
            const modelName = userModelName || 'gemini-2.5-flash';
            
            // --- å¼€å§‹è¯·æ±‚ ---
            
            genReadingBtn.disabled = true;
            genReadingBtn.innerHTML = '<span class="inline-flex items-center justify-center"><span id="ai-loader" class="loader mr-2"></span>æ­£åœ¨ç”Ÿæˆ...</span>';
            aiOutputSection.style.display = 'block'; 
            
            geminiReadingOutput.innerHTML = '<div class="flex items-center justify-center p-8"><div class="loader"></div><span class="ml-3 text-slate-500">AI æ­£åœ¨åŠªåŠ›åˆ›ä½œä¸­ï¼Œè¯·ç¨å€™...</span></div>';
            geminiUnusedContainer.style.display = 'none';
            geminiAnalysisContainer.style.display = 'none';
            geminiTranslationContainer.style.display = 'none';
            geminiUnusedOutput.innerHTML = '';
            geminiAnalysisOutput.innerHTML = '';
            geminiTranslationOutput.innerHTML = '';
            aiUsedCountEl.textContent = '0';
            currentRealUsedExtractItems = [];
            currentAiUsedCount = 0;
            confirmExtractBtn.style.display = 'none';
            exportArticleBtn.style.display = 'none';

            const { systemPrompt, userQuery } = buildGeminiPrompt(themeFinal, wordListString);
            const payload = buildGeminiPayload(systemPrompt, userQuery); 
            
            let apiUrl = '';
            let headers = { 'Content-Type': 'application/json' };

            const googleApiEndpointPath = `${GOOGLE_API_PATH_PREFIX}${modelName}:generateContent`;

            if (userApiEndpoint) {
                // ä½¿ç”¨ç”¨æˆ·è‡ªå®šä¹‰çš„ä»£ç†åœ°å€
                let baseEndpoint = userApiEndpoint;
                if (baseEndpoint.endsWith('/v1')) {
                    // é€‚é… /v1 ç»“å°¾çš„ä»£ç†
                    baseEndpoint = baseEndpoint.slice(0, -3);
                }
                
                apiUrl = baseEndpoint + googleApiEndpointPath;
                // ä»£ç†é€šå¸¸éœ€è¦ Bearer Token
                headers['Authorization'] = `Bearer ${apiKey}`;
                
            } else {
                // ä½¿ç”¨ Google å®˜æ–¹åœ°å€
                apiUrl = GOOGLE_API_BASE_URL + googleApiEndpointPath + `?key=${apiKey}`;
            }

            let jsonString = '';
            let cleanedJsonString = ''; // [ä¿®å¤] ä½œç”¨åŸŸæå‡
                    
            try {
                // [Canvas] å¢åŠ æŒ‡æ•°é€€é¿é‡è¯•
                const response = await fetchWithRetry(apiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(payload)
                }, 3); // é‡è¯•3æ¬¡

                if (!response.ok) {
                    const errorBody = await response.text();
                    console.error("API Error Response:", errorBody);
                    try {
                        const errorJson = JSON.parse(errorBody);
                        if (errorJson.error && errorJson.error.message) {
                            if (errorJson.error.message.includes("model") && errorJson.error.message.includes("not found")) {
                                throw new Error(`API è¯·æ±‚å¤±è´¥ (404 Not Found): æ¨¡å‹åç§° "${modelName}" æœªæ‰¾åˆ°ã€‚è¯·åœ¨ AI è®¾ç½®ä¸­æ£€æŸ¥æ¨¡å‹åç§°ã€‚`);
                            }
                            throw new Error(`API request failed with status ${response.status}: ${errorJson.error.message}`);
                        }
                    } catch (e) {
                         // errorBody ä¸æ˜¯ JSON
                         throw new Error(`API request failed with status ${response.status}: ${errorBody}`);
                    }
                    // å¤‡ç”¨é”™è¯¯
                    throw new Error(`API request failed with status ${response.status}: ${errorBody}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0]) {
                    jsonString = result.candidates[0].content.parts[0].text;
                }

                if (jsonString) {
                    try {
                        // ç§»é™¤å¯èƒ½çš„ markdown æ ‡è®°
                        cleanedJsonString = jsonString.replace(/^```json\s*|```\s*$/g, '');
                        
                        // è§£ç  HTML å®ä½“
                        cleanedJsonString = decodeHTMLEntities(cleanedJsonString);
                        
                        const data = JSON.parse(cleanedJsonString);
                        
                        // [ä¿®å¤] V5 BUG - æ£€æŸ¥ data.passageContent
                        if (!data.passageTitle || !data.passageContent || !data.usedWords) {
                             console.error("AI returned invalid structure:", data);
                             let errorContent = data.passageTitle || (data.passage ? data.passage : (data.passageContent ? data.passageContent : JSON.stringify(data)));
                             showAiError(`AI è¿”å›äº†æ— æ•ˆçš„æ•°æ®ç»“æ„ï¼ˆå¯èƒ½ä¸¢å¤±äº† usedWords åˆ—è¡¨æˆ–æ–‡ç« å†…å®¹ï¼‰ã€‚\nAI çš„å›å¤æ˜¯ï¼š${escapeHTML(errorContent)}`);
                             return;
                        }

                        // [ä¿®å¤] åœ¨æ¸²æŸ“å‰ï¼Œå…ˆè®¡ç®—â€œçœŸå®â€ç”¨è¯ï¼Œä»¥ç¡®ä¿è®¡æ•°å‡†ç¡®
                        const validationResult = validateAndGetRealUsedWords(currentExtract, data.usedWords);
                        currentRealUsedExtractItems = validationResult.realUsedItems;
                        currentAiUsedCount = currentRealUsedExtractItems.length; // [ä¿®å¤] ä½¿ç”¨çœŸå®è®¡æ•°
                        
                        // 1. æ¸²æŸ“æ–‡ç« 
                        const title = escapeHTML(data.passageTitle);
                        let content = escapeHTML(data.passageContent);
                        // [ä¿®å¤] æ›¿æ¢ \n å’Œ \\n
                        content = content.replace(/(\\n|\n){2,}/g, '<br><br>').replace(/(\\n|\n)/g, '<br>');
                        content = renderBold(content); // æ¸²æŸ“æ–‡ç« åŠ ç²—
                        
                        // [ä¿®å¤] ä½¿ç”¨ AI è¿”å›çš„åŸå§‹åˆ—è¡¨è¿›è¡Œé«˜äº®ï¼Œä»¥åŒ¹é…æ–‡ç« 
                        content = highlightWords(content, data.usedWords); 
                        
                        geminiReadingOutput.innerHTML = `<h3 class="text-2xl font-bold text-center mb-5">${title}</h3><div class="space-y-4">${content}</div>`;

                        // 2. å­˜å‚¨ç”¨è¯åˆ—è¡¨å’Œæ•°é‡
                        aiUsedCountEl.textContent = currentAiUsedCount; // [ä¿®å¤] ä½¿ç”¨çœŸå®è®¡æ•°
                        
                        // 3. æ¸²æŸ“æœªä½¿ç”¨çš„è¯
                        const unusedWordsList = validationResult.unusedItems;
                        if (unusedWordsList.length > 0) {
                            geminiUnusedOutput.innerHTML = unusedWordsList.map(item => `<span>${item.word} (${item.part} ${item.meaning})</span>`).join('<br>');
                            geminiUnusedContainer.style.display = 'block';
                        } else {
                            geminiUnusedContainer.style.display = 'none';
                        }
                        
                        // 4. æ¸²æŸ“æ–‡ç« è§£æ
                        if (data.analysis) {
                            let analysisHtml = '';
                            if (data.analysis.structure) {
                                let structure = escapeHTML(data.analysis.structure).replace(/(\\n|\n){2,}/g, '<br><br>').replace(/(\\n|\n)/g, '<br>'); // [ä¿®å¤]
                                analysisHtml += `<p><strong>è¡Œæ–‡ç»“æ„ï¼š</strong>${renderBold(structure)}</p>`;
                            }
                            if (data.analysis.understanding) {
                                let understanding = escapeHTML(data.analysis.understanding).replace(/(\\n|\n){2,}/g, '<br><br>').replace(/(\\n|\n)/g, '<br>'); // [ä¿®å¤]
                                analysisHtml += `<p class="mt-3"><strong>æ–‡ç« ç†è§£ï¼š</strong>${renderBold(understanding)}</p>`;
                            }
                            geminiAnalysisOutput.innerHTML = analysisHtml;
                            geminiAnalysisContainer.style.display = 'block';
                        }
                        
                        // 5. æ¸²æŸ“å…¨æ–‡ç¿»è¯‘
                        if (data.translation) {
                            let translation = escapeHTML(data.translation).replace(/(\\n|\n){2,}/g, '<br><br>').replace(/(\\n|\n)/g, '<br>'); // [ä¿®å¤]
                            geminiTranslationOutput.innerHTML = `<p>${renderBold(translation)}</p>`; // [ä¿®å¤] æ·»åŠ  renderBold
                            geminiTranslationContainer.style.display = 'block';
                        }

                        // 6. å¯ç”¨"ç¡®è®¤æŠ½å–" å’Œ â€œå¯¼å‡ºâ€ æŒ‰é’®
                        if (currentAiUsedCount > 0) { // [ä¿®å¤] å¿…é¡»æ£€æŸ¥çœŸå®è®¡æ•°
                            confirmExtractBtn.style.display = 'block';
                            confirmExtractBtn.disabled = false;
                            confirmExtractBtn.textContent = `3. âœ… ç¡®è®¤æŠ½å– (æ°¸ä¹…ç§»é™¤ ${currentAiUsedCount} ä¸ªé‡Šä¹‰)`;
                            
                            exportArticleBtn.style.display = 'block';
                            exportArticleBtn.disabled = false;
                        } else {
                            // å³ä½¿ AI æœªä½¿ç”¨ä»»ä½•è¯æ±‡
                            confirmExtractBtn.style.display = 'none';
                            confirmExtractBtn.disabled = true;
                            
                            exportArticleBtn.style.display = 'block'; // ä»ç„¶å…è®¸å¯¼å‡º
                            exportArticleBtn.disabled = false; // å³ä½¿0ä¸ªè¯ä¹Ÿå…è®¸å¯¼å‡º
                        }

                    } catch (jsonError) { 
                        // JSON è§£æå¤±è´¥
                        console.error("JSON parsing failed:", jsonError, jsonString);
                        // [ä¿®å¤] ç¡®ä¿ cleanedJsonString åœ¨æ­¤ä½œç”¨åŸŸå¯è§
                        showAiError(`AI è¿”å›äº†æ— æ•ˆçš„ JSON æ•°æ®ã€‚è¯·æ£€æŸ¥ä»£ç†è®¾ç½®æˆ–å¯†é’¥ã€‚\n\næœåŠ¡å™¨åŸå§‹å“åº”:\n${escapeHTML(cleanedJsonString || jsonString)}`);
                    }
                
                } else { 
                    // AI å“åº”ä¸ºç©ºæˆ–æ ¼å¼ä¸ç¬¦
                    console.error("AI å“åº”æ ¼å¼æ— æ•ˆæˆ–ä¸ºç©º: ", result);
                    showAiError("æŠ±æ­‰ï¼ŒAI å“åº”æ ¼å¼æ— æ•ˆã€‚");
                }
            
            } catch (error) { 
                // Fetch æˆ– é‡è¯• å¤±è´¥
                console.error("AI Request Failed:", error);
                let errorMsg = "æŠ±æ­‰ï¼ŒAI è¯·æ±‚å¤±è´¥ã€‚è¯·ç¨åå†è¯•ã€‚";
                if (error.message && error.message.includes("401")) {
                     errorMsg = "AI è¯·æ±‚å¤±è´¥ (401 Unauthorized)ï¼šè¯·æ£€æŸ¥æ‚¨çš„ API å¯†é’¥æ˜¯å¦æ­£ç¡®ã€æ˜¯å¦è¿˜æœ‰é¢åº¦ã€‚";
                } else if (error.message && error.message.includes("403")) {
                    errorMsg = "AI è¯·æ±‚å¤±è´¥ (403 Forbidden)ï¼šè¯·æ£€æŸ¥æ‚¨çš„ API å¯†é’¥æ˜¯å¦æ­£ç¡®ã€æ˜¯å¦å·²å¯ç”¨ã€‚";
                } else if (error.message && error.message.includes("404")) {
                     errorMsg = `AI è¯·æ±‚å¤±è´¥ (404 Not Found)ï¼šè¯·æ£€æŸ¥æ‚¨çš„â€œAPI åŸºç¡€åœ°å€â€å’Œâ€œAI æ¨¡å‹åç§°â€(${modelName})æ˜¯å¦æ­£ç¡®ã€‚`;
                } else if (error.message && error.message.includes("429")) {
                     errorMsg = "AI è¯·æ±‚å¤±è´¥ (429 Quota Exceeded)ï¼šæ‚¨å·²è¶…å‡ºé…é¢ã€‚å¦‚æœæ˜¯å…è´¹å¯†é’¥ï¼Œè¯·ç»‘å®šç»“ç®—è´¦æˆ·æˆ–ç­‰å¾…é…é¢åˆ·æ–°ã€‚";
                } else if (error.message && error.message.includes("503")) {
                     errorMsg = `AI è¯·æ±‚å¤±è´¥ (503 Service Unavailable)ï¼šä»£ç†æœåŠ¡å™¨çš„åç«¯æ¸ é“ä¸å¯ç”¨ã€‚\n(${error.message})`;
                } else if (error.message) {
                    errorMsg += `\n(${error.message})`;
                }
                showAiError(errorMsg);
            } finally { 
                // æ— è®ºæˆåŠŸå¤±è´¥ï¼Œæ¢å¤æŒ‰é’®
                genReadingBtn.disabled = false;
                genReadingBtn.innerHTML = '2. âœ¨ AI ç”Ÿæˆè€ƒç ”é˜…è¯»';
            }
        }
        
        /**
         * [Canvas] å¸¦æŒ‡æ•°é€€é¿çš„ Fetch
         */
        async function fetchWithRetry(url, options, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    // åªæœ‰ 5xx å’Œ 429 é”™è¯¯æ‰é‡è¯•
                    if (response.status < 500 && response.status !== 429) {
                        return response; // ç«‹å³è¿”å›æˆåŠŸæˆ–å®¢æˆ·ç«¯é”™è¯¯ (å¦‚ 400, 401, 404)
                    }
                    if (i === retries - 1) {
                        return response; // æœ€åä¸€æ¬¡å°è¯•ï¼Œè¿”å›å¤±è´¥çš„å“åº”
                    }
                    // ç­‰å¾…åé‡è¯•
                    await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                } catch (error) {
                    if (i === retries - 1) {
                        throw error; // æœ€åä¸€æ¬¡å°è¯•å¤±è´¥ï¼ŒæŠ›å‡ºé”™è¯¯
                    }
                    // ç­‰å¾…åé‡è¯•
                    await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                }
            }
        }
        
        /**
         * æ„å»º Gemini çš„ Prompt (V14 - ä¿®å¤ AIâ€œè·‘é¢˜â€å’Œâ€œç‚«æŠ€â€BUG)
         */
        function buildGeminiPrompt(themeFinal, wordListString) {
            
            // [ä¿®å¤] è¿™æ˜¯åŸºäºæ‚¨â€œåˆ»è–„å°–é”â€çš„ä¿®æ”¹æ„è§ä¼˜åŒ–çš„æ–°ç‰ˆæç¤ºè¯
            const systemPrompt = `
[TASK]
You are a JSON generator. Your task is to generate a JSON object that adheres *perfectly* to the provided SCHEMA.

[INPUT DATA]
1.  **THEME**: ${themeFinal} (You MUST focus on ONLY ONE sub-topic. Actively AVOID generic topics like 'AI ethics'. Be specific, current, and academic.)
2.  **VOCABULARY LIST**:
${wordListString}

[QUALITY STANDARD & RULES (ABSOLUTELY MANDATORY)]
1.  **LOGIC FIRST (THE 'ANTI-VOCAB-SHOW' RULE)**: 
    * The article's quality (logical flow, tight argument, authoritative tone like 'The Economist') is the #1 priority.
    * **WHAT TO AVOID (CRITICAL FAILURE)**: DO NOT write a "vocabulary show" ("è¯æ±‡ç§€"). DO NOT force vocabulary where it doesn't belong ("è¯æ±‡ä¸²çƒ§"). DO NOT create awkward, unnatural sentences just to use a word. DO NOT use generic "moral anxiety" ("å‡å¤§ç©º"). The text must be natural and professional.
2.  **NATURAL USAGE**: 
    * While respecting Rule #1, you MUST *diligently attempt* to integrate as many words as possible from the VOCABULARY LIST naturally.
    * It is better to use fewer words in a high-quality article than to use many words in a low-quality, unnatural article.
3.  **ACCURATE COUNTING**: 
    * The \`usedWords\` list in the JSON *must* be an accurate, complete list of *only* the words from the VOCABULARY LIST that were used in the \`passageContent\`.
    * The \`meaning\` field in \`usedWords\` *must* be the Chinese meaning *exactly* as provided in the VOCABULARY LIST for that word.
4.  **DEEP ANALYSIS (MANDATORY)**: 
    * The 'analysis' section must be in-depth and academic (in Chinese).
    * 'structure': Analyze the logical flow and argumentation of the paragraphs.
    * 'understanding': Analyze the main idea, author's tone, and potential exam questions.
5.  **NO META-COMMENTS (CRITICAL FAILURE)**: 
    * Your response MUST be a pure JSON string. 
    * **ABSOLUTELY DO NOT** include *any* meta-comments, thoughts, or notes (e.g., "(Sample Article...)", "Note:...", "Here is the JSON...", "(Avoiding common topics...)"). This will break the application.
6.  **SCHEMA ADHERENCE**: The output *must* follow the SCHEMA.

[SCHEMA]
(Defined in the \`generationConfig.responseSchema\`)
`;
            
            const userQuery = `Generate the JSON according to all rules.`; 
            
            return { systemPrompt, userQuery };
        }

        /**
         * æ„å»º Gemini çš„ Payload (V7 - æ‹å¹³ Schema)
         */
        function buildGeminiPayload(systemPrompt, userQuery) {
            return {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            // [ä¿®å¤] â€œæ‹å¹³â€ç»“æ„ï¼Œé¿å…AIç†è§£é”™è¯¯
                            passageTitle: { 
                                type: "STRING",
                                description: "The English title of the article." 
                            },
                            passageContent: { 
                                type: "STRING",
                                description: "The full English content of the article (300-400 words). Use \\n\\n for paragraph breaks."
                            },
                            analysis: {
                                type: "OBJECT",
                                properties: {
                                    structure: { type: "STRING", description: "Analysis of the article's structure (in Chinese). Use \\n for newlines." },
                                    understanding: { type: "STRING", description: "Analysis of the main idea and potential test points (in Chinese). Use \\n for newlines." }
                                }
                            },
                            translation: { 
                                type: "STRING",
                                description: "The full Chinese translation of the article. Use \\n\\n for paragraph breaks." 
                            },
                            usedWords: {
                                type: "ARRAY",
                                description: "A list of ALL words from the VOCABULARY LIST that were used in the passageContent.",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        word: { type: "STRING", description: "The English word used (e.g., 'accelerate')." },
                                        meaning: { type: "STRING", description: "The Chinese meaning *exactly* as provided in the vocabulary list (e.g., 'åŠ é€Ÿï¼Œä¿ƒè¿›')." }
                                    },
                                    required: ["word", "meaning"] // å¼ºåˆ¶è¦æ±‚
                                }
                            }
                        },
                         required: ["passageTitle", "passageContent", "analysis", "translation", "usedWords"] // å¼ºåˆ¶è¦æ±‚
                    }
                }
            };
        }
        
        /**
         * æ¸²æŸ“åŠ ç²— (**)
         */
        function renderBold(text) {
             if (!text) return '';
             // å°† **word** æ›¿æ¢ä¸º <strong>word</strong>
             // ä½¿ç”¨éè´ªå©ªåŒ¹é… (.*?)
            return text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        }

        /**
         * HTML è½¬ä¹‰
         */
        function escapeHTML(str) {
            if (!str) return '';
            str = str.replace(/&/g, '&amp;');
            return str.replace(/[<>"']/g, function(match) {
                return {
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                }[match];
            });
        }
        
        /**
         * é«˜äº®æ–‡ç« ä¸­çš„å•è¯ (V3 - ä½¿ç”¨å•ä¸€æ­£åˆ™)
         */
        function highlightWords(content, usedWords) {
            if (!usedWords || usedWords.length === 0) return content;
            
            const wordMap = new Map();
            usedWords.forEach(item => {
                if (item && item.word && typeof item.meaning !== 'undefined') {
                    // æå–çº¯è‹±æ–‡å•è¯
                    const wordMatch = item.word.match(/^[a-zA-Z-]+/);
                    if (!wordMatch) return; // å¦‚æœæ²¡æœ‰åŒ¹é…åˆ°è‹±æ–‡å•è¯ï¼Œåˆ™è·³è¿‡
                    
                    const word = wordMatch[0];
                    const meaning = item.meaning; // å¿…é¡»ä½¿ç”¨ schema ä¸­çš„ meaning å­—æ®µ
                    
                    const wordLower = word.toLowerCase();
                    if (!wordMap.has(wordLower)) {
                        wordMap.set(wordLower, []);
                    }
                    // ç¡®ä¿é‡Šä¹‰ä¸é‡å¤
                    if (!wordMap.get(wordLower).includes(meaning)) {
                         wordMap.get(wordLower).push(meaning);
                    }
                } else {
                    console.warn("Invalid usedWord item (missing word or meaning):", item);
                }
            });
            
            // è½¬ä¹‰å•è¯ä¸­çš„ç‰¹æ®Šæ­£åˆ™å­—ç¬¦
            const uniqueWords = Array.from(wordMap.keys()).map(word => 
                word.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') 
            );
            
            if (uniqueWords.length === 0) return content;
            
            // æŒ‰é•¿åº¦é™åºæ’åºï¼Œä¼˜å…ˆåŒ¹é…é•¿å•è¯ (ä¾‹å¦‚ "part-time" ä¼˜å…ˆäº "part")
            uniqueWords.sort((a, b) => b.length - a.length);
            
            const regex = new RegExp(`\\b(${uniqueWords.join('|')})\\b`, 'gi');
            
            return content.replace(regex, (match) => {
                const wordLower = match.toLowerCase();
                const meanings = wordMap.get(wordLower);

                // å°†æ‰€æœ‰é‡Šä¹‰åˆå¹¶
                const titleText = (meanings && meanings.length > 0) ? `${match} (${meanings.join('; ')})` : match;
                const titleAttr = escapeHTML(titleText);
                
                const cambridgeUrl = `https://dictionary.cambridge.org/zhs/è¯å…¸/è‹±è¯­-æ±‰è¯­-ç®€ä½“/${encodeURIComponent(wordLower)}`;
                
                return `<a href="${cambridgeUrl}" target="_blank" class="highlighted-word" title="${titleAttr}"><u>${match}</u></a>`;
            });
        }

        /**
         * [ä¿®å¤] éªŒè¯AIç”¨è¯ï¼Œè¿”å›â€œçœŸå®â€ç”¨è¯å’Œâ€œæœªä½¿ç”¨â€è¯ (V2 - ä¿®å¤è®¡æ•°BUG)
         */
        function validateAndGetRealUsedWords(extractList, aiUsedList) {
            const realUsedItems = [];
            const realUsedKeys = new Set(); // ç”¨äºå»é‡å’Œå¿«é€ŸæŸ¥æ‰¾
            
            if (aiUsedList) {
                aiUsedList.forEach(aiWord => {
                    if (!aiWord || !aiWord.word || typeof aiWord.meaning === 'undefined') {
                        return; // AI è¿”å›äº†æ— æ•ˆæ ¼å¼
                    }
                    
                    const aiWordLower = aiWord.word.toLowerCase();
                    // [ä¿®å¤] AI è¿”å›çš„ meaning ä¹Ÿå¯èƒ½ä¸æ ‡å‡†
                    const aiMeaningCleaned = aiWord.meaning.toLowerCase().split(';')[0].trim(); // åªå–ç¬¬ä¸€ä¸ªé‡Šä¹‰è¿›è¡Œç²—ç•¥åŒ¹é…

                    // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªåŒ¹é…çš„é‡Šä¹‰å•å…ƒ
                    const matchingExtractItem = extractList.find(item => {
                        const itemMeaningCleaned = item.meaning.toLowerCase().split(';')[0].trim();
                        return item.word.toLowerCase() === aiWordLower && 
                               (item.meaning.toLowerCase() === aiWord.meaning.toLowerCase() || itemMeaningCleaned === aiMeaningCleaned);
                    });

                    if (matchingExtractItem) {
                        // ç¡®ä¿æˆ‘ä»¬åªæ·»åŠ ä¸€æ¬¡
                        const key = `${matchingExtractItem.wordIndex}-${matchingExtractItem.partIndex}-${matchingExtractItem.meaningIndex}`;
                        if (!realUsedKeys.has(key)) {
                            realUsedItems.push(matchingExtractItem);
                            realUsedKeys.add(key);
                        }
                    } else {
                        console.warn("AI used a word/meaning pair not in extract list:", aiWord);
                    }
                });
            }

            // æ‰¾å‡ºæœªä½¿ç”¨çš„
            const unusedItems = extractList.filter(item => {
                const key = `${item.wordIndex}-${item.partIndex}-${item.meaningIndex}`;
                return !realUsedKeys.has(key);
            });

            return { realUsedItems, unusedItems };
        }

        /**
         * æ˜¾ç¤º AI é”™è¯¯
         */
        function showAiError(message) {
            geminiReadingOutput.innerHTML = `<div class="p-4 bg-red-100 border border-red-300 text-red-800 rounded-lg">${escapeHTML(message).replace(/\n/g, '<br>')}</div>`;
            aiOutputSection.style.display = 'block';
            
            geminiUnusedContainer.style.display = 'none';
            geminiAnalysisContainer.style.display = 'none';
            geminiTranslationContainer.style.display = 'none';
            aiUsedCountEl.textContent = '0';
            currentAiUsedCount = 0;
        }
            
        // --- 5. [æ–°åŠŸèƒ½] æ–‡ç« å¯¼å‡º ---
        
        exportArticleBtn.addEventListener('click', handleExportArticle);
        
        /**
         * æ„å»ºå¯¼å‡ºçš„ HTML å†…å®¹
         */
        function buildExportHTML(articleHtml, analysisHtml, translationHtml) {
            const articleTitle = geminiReadingOutput.querySelector('h3')?.textContent || 'å¯¼å‡ºçš„æ–‡ç« ';
            
            // [å…³é”®] å¿…é¡»åŒ…å«é«˜äº®å’ŒåŠ ç²—çš„æ ·å¼
            const exportStyles = `
                body {
                    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
                    line-height: 1.6;
                    background-color: #f8fafc;
                    color: #111827;
                    max-w: 800px;
                    margin: 20px auto;
                    padding: 20px;
                    border: 1px solid #e2e8f0;
                    border-radius: 12px;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.05);
                }
                h1 {
                    font-size: 1.75rem;
                    font-weight: 700;
                    color: #1f2937;
                    border-bottom: 1px solid #cbd5e1;
                    padding-bottom: 10px;
                    margin-bottom: 1.5rem;
                }
                h2 {
                    font-size: 1.25rem;
                    font-weight: 600;
                    color: #1e3a8a; /* è“è‰² */
                    margin-top: 2rem;
                    border-bottom: 1px solid #dbeafe;
                    padding-bottom: 8px;
                }
                .highlighted-word {
                    text-decoration: underline;
                    text-decoration-color: #fdba74;
                    text-decoration-thickness: 2px;
                    color: #1d4ed8;
                    font-weight: 600;
                    cursor: pointer;
                }
                .highlighted-word:hover {
                    background-color: #fef3c7;
                    color: #be123c;
                }
                strong {
                    font-weight: 700;
                    color: #000;
                }
                .analysis, .translation {
                    background-color: #f9fafb;
                    border: 1px solid #f3f4f6;
                    padding: 15px;
                    border-radius: 8px;
                    font-size: 0.95rem;
                }
                .analysis {
                    background-color: #f5f3ff; /* ç´«è‰²-50 */
                    color: #3730a3;
                }
                .translation {
                    background-color: #f8fafc; /* ç°è‰²-50 */
                    color: #374151;
                }
                p { margin-bottom: 1em; }
            `;
            
            return `
                <!DOCTYPE html>
                <html lang="zh-CN">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>${escapeHTML(articleTitle)}</title>
                    <style>
                        ${exportStyles}
                    </style>
                </head>
                <body>
                    <h1>${escapeHTML(articleTitle)}</h1>
                    
                    <section class="article-content">
                        ${articleHtml}
                    </section>
                    
                    <section class="analysis-container">
                        <h2>æ·±åº¦æ–‡ç« è§£æ</h2>
                        <div class="analysis">
                            ${analysisHtml}
                        </div>
                    </section>
                    
                    <section class="translation-container">
                        <h2>å…¨æ–‡ç¿»è¯‘</h2>
                        <div class="translation">
                            ${translationHtml}
                        </div>
                    </section>
                </body>
                </html>
            `;
        }

        /**
         * å¤„ç†å¯¼å‡ºæŒ‰é’®ç‚¹å‡»
         */
        function handleExportArticle() {
            try {
                const articleHtml = geminiReadingOutput.innerHTML;
                const analysisHtml = geminiAnalysisOutput.innerHTML;
                const translationHtml = geminiTranslationOutput.innerHTML;

                if (!articleHtml || geminiReadingOutput.textContent.includes("æŠ±æ­‰")) {
                    showToast("æ²¡æœ‰å¯å¯¼å‡ºçš„æ–‡ç« ");
                    return;
                }

                const fullHtml = buildExportHTML(articleHtml, analysisHtml, translationHtml);
                
                const blob = new Blob([fullHtml], { type: 'text/html;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                
                const title = (geminiReadingOutput.querySelector('h3')?.textContent || 'article-export').replace(/[^a-z0-9\u4e00-\u9fa5]/gi, '-').substring(0, 50);
                a.download = `${title}.html`;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                URL.revokeObjectURL(url);
                
                showToast("æ–‡ç« å¯¼å‡ºæˆåŠŸï¼");

            } catch (e) {
                console.error("å¯¼å‡ºå¤±è´¥:", e);
                showToast("å¯¼å‡ºå¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°");
            }
        }
            
        // --- é¡µé¢åŠ è½½ ---
        document.addEventListener('DOMContentLoaded', () => {
            loadApiSettings(); 
            
            const savedText = localStorage.getItem(TEXT_KEY);
            const savedDB = localStorage.getItem(DB_KEY);

            if (savedText) {
                vocabInput.value = savedText;
            }

            if (savedDB) {
                try {
                    currentDatabase = JSON.parse(savedDB);
                    if (savedText) {
                         originalDatabase = parseVocabText(savedText);
                    } else {
                         originalDatabase = deepClone(currentDatabase);
                    }
                } catch (e) {
                    console.error("Failed to parse saved database from localStorage", e);
                    localStorage.removeItem(DB_KEY);
localStorage.removeItem(TEXT_KEY);
                }
            }
            
            updateTotalStatsDisplay();
            initializeCategorySelection();
            updateDbStatusMonitor(); // [New] Call
        });

    </script>

</body>
</html>








